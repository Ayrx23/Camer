tion animate(){
  requestAnimationFrame(animate);

  const scale=THREE.MathUtils.clamp(1/(pinch*6),.6,3);
  particles.scale.setScalar(scale);

  if(speed>0.03){
    particles.scale.multiplyScalar(1.02);
  }

  particles.rotation.y+=0.002;
  particles.rotation.x+=0.001;

  renderer.render(scene,camera);
}
animate();

/* ---------- RESIZE ---------- */
addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gesture Particles Fixed</title>
<style>
  body { margin: 0; background: black; overflow: hidden; }
  
  #video-container {
    position: fixed; bottom: 20px; left: 20px;
    width: 160px; height: 120px;
    border: 2px solid cyan; border-radius: 8px;
    overflow: hidden;
    z-index: 10;
  }
  
  /* Mirror the video so interaction feels natural */
  #video {
    width: 100%; height: 100%;
    object-fit: cover;
    transform: scaleX(-1); 
  }

  #loading {
    position: fixed; inset: 0;
    display: flex; align-items: center; justify-content: center;
    font-family: monospace; color: #0ff;
    background: #000;
    z-index: 20;
    transition: opacity 0.5s;
  }
  
  #instructions {
    position: fixed; top: 20px; left: 20px;
    color: rgba(255,255,255,0.6);
    font-family: sans-serif; pointer-events: none;
  }
</style>
</head>
<body>

<div id="loading">Initializing Vision & GPUâ€¦</div>
<div id="instructions">
  <b>Pinch</b> to change shape.<br>
  <b>Move fast</b> to expand.
</div>

<div id="video-container">
  <video id="video" autoplay muted playsinline></video>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ---------- THREE.JS SETUP ---------- */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = 100;

const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
document.body.appendChild(renderer.domElement);

/* ---------- PARTICLES ---------- */
const COUNT = 15000;
// We access these arrays via the geometry attributes later
const positions = new Float32Array(COUNT * 3);
const colors = new Float32Array(COUNT * 3);

const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
  size: 0.8,
  vertexColors: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
  transparent: true,
  opacity: 0.8
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

/* ---------- LOGIC & SHAPES ---------- */
let mode = 0;
const modes = ['cloud', 'heart', 'ring', 'spiral'];

function setShape(type) {
  const posArray = geometry.attributes.position.array;
  const colArray = geometry.attributes.color.array;

  for(let i = 0; i < COUNT; i++) {
    const i3 = i * 3;
    let x=0, y=0, z=0;
    let r=1, g=1, b=1;

    // 1. CLOUD (Blue/White)
    if(type === 'cloud') {
      const rad = Math.random() * 50;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos((Math.random() * 2) - 1);
      
      x = rad * Math.sin(phi) * Math.cos(theta);
      y = rad * Math.sin(phi) * Math.sin(theta);
      z = rad * Math.cos(phi);
      
      // Color: Cyan to White
      r = 0.2; g = 0.8 + Math.random()*0.2; b = 1.0;
    }

    // 2. HEART (Red/Pink)
    if(type === 'heart') {
      const t = Math.random() * Math.PI * 2;
      // Heart formula
      x = 16 * Math.pow(Math.sin(t), 3);
      y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
      z = (Math.random() - 0.5) * 10;
      
      // Scale up
      x *= 2.5; y *= 2.5;
      
      // Color: Red/Pink
      r = 1.0; g = 0.1; b = 0.3 + Math.random()*0.5;
    }

    // 3. RING/SATURN (Gold)
    if(type === 'ring') {
      const angle = Math.random() * Math.PI * 2;
      const radius = 45 + Math.random() * 15;
      x = Math.cos(angle) * radius;
      z = Math.sin(angle) * radius;
      y = (Math.random() - 0.5) * 5; // Flat disk

      // Color: Gold/Orange
      r = 1.0; g = 0.8; b = 0.2;
    }

    // 4. SPIRAL (Multi)
    if(type === 'spiral') {
      const t = i * 0.1; 
      const radius = i * 0.005;
      x = radius * 50 * Math.cos(t);
      y = (i * 0.01) - 50; 
      z = radius * 50 * Math.sin(t);

      // Color: Rainbow
      r = Math.sin(i*0.01)*0.5 + 0.5;
      g = Math.cos(i*0.01)*0.5 + 0.5;
      b = Math.sin(i*0.02)*0.5 + 0.5;
    }

    posArray[i3] = x;
    posArray[i3+1] = y;
    posArray[i3+2] = z;

    colArray[i3] = r;
    colArray[i3+1] = g;
    colArray[i3+2] = b;
  }

  geometry.attributes.position.needsUpdate = true;
  geometry.attributes.color.needsUpdate = true;
}

// Initialize with first shape
setShape('cloud');

/* ---------- HAND TRACKING ---------- */
const videoElement = document.getElementById('video');
const loadingElement = document.getElementById('loading');

let pinchDistance = 0.5; // Start with safe value (not 0)
let lastModeSwitchTime = 0;
let lastX = 0;
let handSpeed = 0;

const hands = new Hands({
  locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
  }
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.5,
  minTrackingConfidence: 0.5
});

hands.onResults((results) => {
  // Safe check: ensure landmarks exist and array is not empty
  if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
    handSpeed *= 0.9; // Decelerate if hand is lost
    return; 
  }

  const landmarks = results.multiHandLandmarks[0];
  
  // Index 4 (Thumb Tip) & Index 8 (Index Tip)
  const thumb = landmarks[4];
  const index = landmarks[8];
  
  // Calculate pinch distance (Euclidean 2D)
  const dist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
  
  // Smoothing the pinch value
  pinchDistance += (dist - pinchDistance) * 0.2;

  // Calculate Speed (using Middle Finger MCP x-movement)
  const currentX = landmarks[9].x;
  // If lastX is 0, it's the first frame, don't calc speed
  if(lastX !== 0) {
    const delta = Math.abs(currentX - lastX);
    handSpeed += (delta - handSpeed) * 0.1; // Smooth speed
  }
  lastX = currentX;

  // Switch Mode Logic
  // Using a threshold of 0.05 for "touching"
  if (pinchDistance < 0.05 && (performance.now() - lastModeSwitchTime > 1000)) {
    mode = (mode + 1) % modes.length;
    setShape(modes[mode]);
    lastModeSwitchTime = performance.now();
  }
});

const cameraUtils = new Camera(videoElement, {
  onFrame: async () => {
    await hands.send({image: videoElement});
  },
  width: 640,
  height: 480
});

cameraUtils.start()
  .then(() => {
    loadingElement.style.opacity = 0;
    setTimeout(() => loadingElement.remove(), 500);
  })
  .catch(err => {
    loadingElement.innerHTML = "Camera Error.<br>Please allow access.";
    console.error(err);
  });

/* ---------- LOOP ---------- */
function animate() {
  requestAnimationFrame(animate);

  // Rotate entire system slightly
  particles.rotation.y += 0.002;
  particles.rotation.x += 0.001;

  // Scale based on pinch
  // Prevent division by zero or negative infinity
  const safePinch = Math.max(pinchDistance, 0.01); 
  const targetScale = THREE.MathUtils.clamp(0.2 / safePinch, 0.5, 4.0);
  
  // Smoothly interpolate current scale to target scale
  const currentScale = particles.scale.x;
  const newScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.1);
  
  particles.scale.setScalar(newScale);

  // React to speed (Pulse effect)
  if (handSpeed > 0.02) {
    const pulse = 1 + (handSpeed * 2); 
    particles.scale.multiplyScalar(pulse);
  }

  renderer.render(scene, camera);
}

animate();

/* ---------- RESIZE ---------- */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
