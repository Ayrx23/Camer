<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gesture Alchemy: Solar Edition</title>
<style>
  body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
  #video { position: fixed; bottom: 20px; left: 20px; width: 180px; height: 135px; border: 2px solid #0ff; border-radius: 12px; transform: scaleX(-1); z-index: 10; opacity: 0.7; }
  #loading { position: fixed; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #000; color: #0ff; z-index: 100; }
  #ui { position: fixed; top: 20px; right: 20px; color: #0ff; text-align: right; pointer-events: none; text-transform: uppercase; letter-spacing: 2px; }
  .loader { border: 4px solid #111; border-top: 4px solid #0ff; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px; }
  @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
</style>
</head>
<body>

<div id="loading"><div class="loader"></div>Initializing System...</div>
<div id="ui"><div id="mode-text">SHAPE MODE</div><div id="gesture-hint">CLAP TO EXPLORE SPACE</div></div>
<video id="video" autoplay muted playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ---------- CONFIG & STATE ---------- */
const COUNT = 25000;
let isSolarSystem = false;
let currentMode = 0;
const modes = ['nebula', 'heart', 'torus', 'dna'];
let targetScale = 1;
let currentScale = 1;
let lastSwitch = 0;
let lastClap = 0;

/* ---------- THREE SETUP ---------- */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
camera.position.z = 150;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ---------- PARTICLE SYSTEM ---------- */
const geometry = new THREE.BufferGeometry();
const posArr = new Float32Array(COUNT * 3);
const colArr = new Float32Array(COUNT * 3);
const sizeArr = new Float32Array(COUNT);

geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colArr, 3));

const material = new THREE.PointsMaterial({
  size: 0.7,
  vertexColors: true,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const points = new THREE.Points(geometry, material);
scene.add(points);

/* ---------- SHAPE GENERATORS ---------- */
function updateParticles(type) {
  const positions = geometry.attributes.position.array;
  const colors = geometry.attributes.color.array;

  for(let i=0; i<COUNT; i++) {
    const i3 = i * 3;
    let x, y, z, r, g, b;

    if (isSolarSystem) {
        // Solar System Logic (Simplified orbits)
        const planetIdx = i % 9; 
        const orbitRad = (planetIdx + 1) * 25;
        const angle = (i / COUNT) * Math.PI * 2 + (Math.random() * 0.5);
        x = Math.cos(angle) * orbitRad;
        z = Math.sin(angle) * orbitRad;
        y = (Math.random() - 0.5) * 2;
        r = 0.5 + Math.random() * 0.5; g = 0.7; b = 1.0;
        if(planetIdx === 0) { x=y=z=0; r=1; g=0.6; b=0; } // The Sun
    } else {
        if(type === 'nebula') {
            const rad = Math.random() * 60;
            const a = Math.random() * Math.PI * 2;
            x = Math.cos(a) * rad; y = Math.sin(a) * rad; z = (Math.random()-0.5) * 40;
            r = 0.2; g = 0.4; b = 1;
        } else if(type === 'heart') {
            const t = Math.random() * Math.PI * 2;
            x = 16 * Math.pow(Math.sin(t), 3);
            y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            z = (Math.random() - 0.5) * 15;
            x *= 2.5; y *= 2.5; r = 1; g = 0.2; b = 0.4;
        } else if(type === 'torus') {
            const a = Math.random() * Math.PI * 2;
            const b_ = Math.random() * Math.PI * 2;
            const R = 50, rr = 15;
            x = (R + rr * Math.cos(b_)) * Math.cos(a);
            y = (R + rr * Math.cos(b_)) * Math.sin(a);
            z = rr * Math.sin(b_);
            r = 0.8; g = 0.2; b = 1;
        } else if(type === 'dna') {
            const t = (i / COUNT) * 40;
            const side = i % 2 === 0 ? 1 : -1;
            x = Math.cos(t) * 20 * side;
            z = Math.sin(t) * 20 * side;
            y = t * 4 - 80;
            r = side > 0 ? 0 : 1; g = 1; b = side > 0 ? 1 : 0;
        }
    }

    positions[i3] = x; positions[i3+1] = y; positions[i3+2] = z;
    colors[i3] = r; colors[i3+1] = g; colors[i3+2] = b;
  }
  geometry.attributes.position.needsUpdate = true;
  geometry.attributes.color.needsUpdate = true;
}

updateParticles(modes[0]);

/* ---------- GESTURE ENGINE ---------- */
const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6 });

hands.onResults(res => {
  if (!res.multiHandLandmarks || res.multiHandLandmarks.length === 0) return;

  const h1 = res.multiHandLandmarks[0];
  const h2 = res.multiHandLandmarks[1];

  // 1. PINCH TO CHANGE SHAPE (Right hand index/thumb)
  const pinch = Math.hypot(h1[4].x - h1[8].x, h1[4].y - h1[8].y);
  if (pinch < 0.04 && performance.now() - lastSwitch > 800) {
    if(!isSolarSystem) {
        currentMode = (currentMode + 1) % modes.length;
        updateParticles(modes[currentMode]);
        document.getElementById('mode-text').innerText = modes[currentMode];
    }
    lastSwitch = performance.now();
  }

  // 2. TWO HAND SCALE & CLAP
  if (h2) {
    const handDist = Math.hypot(h1[9].x - h2[9].x, h1[9].y - h2[9].y);
    
    // Scale mapping
    targetScale = THREE.MathUtils.mapLinear(handDist, 0.1, 0.7, 0.5, 3.5);

    // CLAP DETECT (Sudden closeness)
    if (handDist < 0.08 && performance.now() - lastClap > 1500) {
        isSolarSystem = !isSolarSystem;
        updateParticles(isSolarSystem ? 'solar' : modes[currentMode]);
        document.getElementById('mode-text').innerText = isSolarSystem ? "SOLAR SYSTEM" : modes[currentMode];
        lastClap = performance.now();
    }
  }
});

const video = document.getElementById('video');
const cam = new Camera(video, { onFrame: async () => await hands.send({image: video}), width: 640, height: 480 });
cam.start().then(() => document.getElementById('loading').remove());

/* ---------- SMOOTH ANIMATION LOOP ---------- */
function animate() {
  requestAnimationFrame(animate);

  // Oily Smooth Scaling (LERP)
  currentScale += (targetScale - currentScale) * 0.1;
  points.scale.setScalar(currentScale);

  // Rotation
  points.rotation.y += isSolarSystem ? 0.005 : 0.002;
  points.rotation.x += 0.001;

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>

