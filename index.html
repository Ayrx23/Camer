<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gesture Particles Pro</title>
<style>
body { margin:0; background:black; overflow:hidden }
#video-container {
  position:fixed; bottom:15px; left:15px;
  width:160px; height:120px;
  border:2px solid cyan; border-radius:10px;
  overflow:hidden; opacity:.9; z-index:10;
}
#video { width:100%; height:100%; object-fit:cover; transform:scaleX(-1) }
#loading {
  position:fixed; inset:0; display:flex;
  align-items:center; justify-content:center;
  color:#0ff; font-family:monospace;
  background:black; z-index:20;
}
#modeLabel {
  position:fixed; top:15px; right:20px;
  color:#0ff; font-family:monospace;
  opacity:.8;
}
</style>
</head>
<body>

<div id="loading">Initializing Vision & GPUâ€¦</div>
<div id="modeLabel"></div>

<div id="video-container">
  <video id="video" autoplay muted playsinline></video>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ---------- THREE ---------- */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = 120;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
document.body.appendChild(renderer.domElement);

/* ---------- PARTICLES ---------- */
const COUNT = 18000;
const pos = new Float32Array(COUNT*3);
const col = new Float32Array(COUNT*3);

const geo = new THREE.BufferGeometry();
geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
geo.setAttribute('color', new THREE.BufferAttribute(col,3));

const mat = new THREE.PointsMaterial({
  size:1,
  vertexColors:true,
  blending:THREE.AdditiveBlending,
  transparent:true,
  depthWrite:false
});

const points = new THREE.Points(geo,mat);
scene.add(points);

/* ---------- MODES ---------- */
let shapeMode = true;
let modeIndex = 0;
const shapes = ['cloud','heart','flower','torus','spiral','galaxy'];
const label = document.getElementById('modeLabel');

function setLabel(text){ label.textContent = text }

/* ---------- SHAPES ---------- */
function setShape(type){
  for(let i=0;i<COUNT;i++){
    const i3=i*3;
    let x=0,y=0,z=0,r=1,g=1,b=1;

    if(type==='cloud'){
      const a=Math.random()*Math.PI*2;
      const d=Math.random()*50;
      x=Math.cos(a)*d; y=Math.sin(a)*d; z=(Math.random()-.5)*30;
      r=0.2; g=0.8; b=1;
    }

    if(type==='heart'){
      const t=Math.random()*Math.PI*2;
      x=16*Math.pow(Math.sin(t),3);
      y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
      z=(Math.random()-.5)*10;
      x*=2.5; y*=2.5;
      r=1; g=0.2; b=0.4;
    }

    if(type==='flower'){
      const t=Math.random()*Math.PI*2;
      const k=6;
      const rad=30*Math.cos(k*t);
      x=Math.cos(t)*rad;
      y=Math.sin(t)*rad;
      z=(Math.random()-.5)*10;
      r=1; g=0.5; b=0.8;
    }

    if(type==='torus'){
      const a=Math.random()*Math.PI*2;
      const b2=Math.random()*Math.PI*2;
      const R=40, r2=10;
      x=(R+r2*Math.cos(b2))*Math.cos(a);
      y=(R+r2*Math.cos(b2))*Math.sin(a);
      z=r2*Math.sin(b2);
      r=0.6; g=0.9; b=1;
    }

    if(type==='spiral'){
      const t=i*0.02;
      x=Math.cos(t)*t;
      z=Math.sin(t)*t;
      y=(i/COUNT-0.5)*80;
      r=Math.sin(t)*.5+.5;
      g=Math.cos(t)*.5+.5;
      b=1;
    }

    if(type==='galaxy'){
      const a=Math.random()*Math.PI*2;
      const r3=Math.random()*60;
      x=Math.cos(a)*r3;
      z=Math.sin(a)*r3;
      y=(Math.random()-.5)*10;
      r=1; g=1; b=1;
    }

    pos[i3]=x; pos[i3+1]=y; pos[i3+2]=z;
    col[i3]=r; col[i3+1]=g; col[i3+2]=b;
  }
  geo.attributes.position.needsUpdate=true;
  geo.attributes.color.needsUpdate=true;
}

setShape(shapes[0]);
setLabel("Mode: Shapes");

/* ---------- SOLAR SYSTEM ---------- */
function setSolar(){
  const planets=[
    {r:0,c:[1,1,0]}, // sun
    {r:15,c:[0.7,0.7,0.7]},
    {r:25,c:[1,0.6,0.2]},
    {r:35,c:[0.2,0.6,1]},
    {r:50,c:[1,0.4,0.4]}
  ];
  for(let i=0;i<COUNT;i++){
    const p=planets[i%planets.length];
    const a=Math.random()*Math.PI*2;
    pos[i*3]=Math.cos(a)*p.r;
    pos[i*3+1]=(Math.random()-.5)*3;
    pos[i*3+2]=Math.sin(a)*p.r;
    col[i*3]=p.c[0];
    col[i*3+1]=p.c[1];
    col[i*3+2]=p.c[2];
  }
  geo.attributes.position.needsUpdate=true;
  geo.attributes.color.needsUpdate=true;
  setLabel("Mode: Solar System");
}

/* ---------- HAND TRACKING ---------- */
const video=document.getElementById('video');
let pinch=0.5, handDist=0.5;
let lastClap=0;

const hands=new Hands({
  locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands:2,
  minDetectionConfidence:.6,
  minTrackingConfidence:.6
});

hands.onResults(res=>{
  if(!res.multiHandLandmarks) return;

  if(res.multiHandLandmarks.length===1){
    const lm=res.multiHandLandmarks[0];
    pinch=Math.hypot(lm[4].x-lm[8].x,lm[4].y-lm[8].y);
    if(pinch<0.05){
      modeIndex=(modeIndex+1)%shapes.length;
      setShape(shapes[modeIndex]);
      setLabel("Mode: "+shapes[modeIndex]);
    }
  }

  if(res.multiHandLandmarks.length===2){
    const a=res.multiHandLandmarks[0][9];
    const b=res.multiHandLandmarks[1][9];
    const d=Math.hypot(a.x-b.x,a.y-b.y);

    if(d<0.08 && performance.now()-lastClap>1500){
      shapeMode=!shapeMode;
      shapeMode?setShape(shapes[modeIndex]):setSolar();
      setLabel(shapeMode?"Mode: Shapes":"Mode: Solar System");
      lastClap=performance.now();
    }
    handDist=d;
  }
});

new Camera(video,{
  onFrame:async()=>hands.send({image:video}),
  width:640,height:480
}).start().then(()=>loading.remove());

/* ---------- LOOP ---------- */
function animate(){
  requestAnimationFrame(animate);

  const s=THREE.MathUtils.lerp(points.scale.x,1/(pinch*5),0.08);
  points.scale.setScalar(THREE.MathUtils.clamp(s,0.6,3));

  points.rotation.y+=0.001+handDist*0.01;
  points.rotation.x+=0.0005;

  renderer.render(scene,camera);
}
animate();

/* ---------- RESIZE ---------- */
addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>

